'use strict';

const constant = require('../constant/global'),
  util = require('./common'),
  crypto = require('crypto'),
  nacl = require('tweetnacl'),
  RIPEMD160 = require('ripemd160');

const _ENCODING = constant.crypto.encoding,
  _ALGORITHM = constant.crypto.algorithm,
  _SALT_SIZE = constant.crypto.saltSize,
  _IV_SIZE = constant.crypto.ivSize,
  _TYPE_ED25519 = constant.crypto.typeEd25519,
  _PUBKEY_PREFIX = constant.crypto.pubkeyPrefix;

class Crypto {
  constructor() { }
  /**
   * Generating a 32 bytes of hex string
   * @param {String} mnemonic a random string
   */
  static hashSeed(seed = '', option = {}) {
    let hash = crypto
      .createHash(option.algorithm || _ALGORITHM)
      .update(seed)
      .digest(option.encoding || _ENCODING)
      .toUpperCase();
    return hash;
  }

  /**
   * Generating a key pair
   * @param {String} seedHash a string which hash of seed content
   */
  static makeKeyPair(seedHash) {
    if (!util._isSeedHash(seedHash)) {
      throw new Error('String is not a valid seed hash');
    }
    let buffer = new Buffer(seedHash, 'hex');
    let keyPair = this.makeKeyPairFromSeed(buffer);
    return {
      publicKey: keyPair.publicKey,
      privateKey: keyPair.privateKey || keyPair.secretKey
    }
  }

  /**
   * Derive secret key from password with key derivation function
   * @param {String} password [User supplied password]
   * @param {String} salt [Randomly generated bytes]
   * @param {Object} option [Key derivation parameters]
   * @returns {Buffer} [Secret key derived from password]
   */
  static deriveKey(password, salt, option) {
    var prf;
    option.kdfparams = option.kdfparams || {};

    if (typeof password === 'undefined' || password === null || !salt) {
      throw new Error('Must provide password and salt to derive a key');
    }

    password = util._strToBuffer(password, 'utf8');
    salt = util._strToBuffer(salt, 'utf8');

    if (option.kdf !== 'pbkdf2') {
      throw new Error('KDF method is not available yet. Please use pbkdf2 for now');
    }

    prf = option.kdfparams.prf || constant.crypto.kdf.pbkdf2.prf;
    if (prf === 'hmac-sha256') prf = constant.crypto.kdf.pbkdf2.hash;

    return crypto.pbkdf2Sync(
      password, salt,
      option.kdfparams.c || constant.crypto.kdf.pbkdf22.c,
      option.kdfparams.dklen || constant.crypto.kdf.pbkdf22.dklen,
      prf
    )
  }

  /**
   * Assemble key data object in secret-storage format.
   * @param {buffer} derivedKey Password-derived secret key.
   * @param {buffer} privateKey Private key.
   * @param {buffer} salt Randomly generated salt.
   * @param {buffer} iv Initialization vector.
   * @param {Object=} options Encryption parameters.
   * @param {string=} options.kdf Key derivation function (default: pbkdf2).
   * @param {string=} options.cipher Symmetric cipher (default: constants.cipher).
   * @param {Object=} options.kdfparams KDF parameters (default: constants.<kdf>).
   * @return {Object}
   */
  static marshal(derivedKey, privateKey, salt, iv, option = {}) {
    var ciphertext, keyObject, algo;
    option = option || {};
    option.kdfparams = option.kdfparams || {};
    algo = option.cipher || constant.crypto.kdf.pbkdf2.cipher;

    // encrypt using first 16 bytes of derived key
    ciphertext = this.encrypt(privateKey, derivedKey.slice(0, 16), iv, algo).toString('hex');

    keyObject = {
      address: this.getAddressByPrivKey(privateKey).slice(2),
      crypto: {
        cipher: option.cipher || constant.crypto.kdf.pbkdf2.cipher,
        ciphertext: ciphertext,
        cipherparams: { iv: iv.toString('hex') },
        mac: this.createMac(derivedKey, ciphertext)
      }
    };

    if (option.kdf === 'pbkdf2') {
      keyObject.crypto.kdf = 'pbkdf2';
      keyObject.crypto.kdfparams = {
        c: option.kdfparams.c || this.constants.pbkdf2.c,
        dklen: option.kdfparams.dklen || this.constants.pbkdf2.dklen,
        prf: option.kdfparams.prf || this.constants.pbkdf2.prf,
        salt: salt.toString('hex')
      };
    }

    return keyObject;
  }

  /**
   * Symmetric private key encryption using secret (derived) key.
   * @param {String} text Data to be encrypted.
   * @param {Buffer|} key Secret key.
   * @param {Buffer|} iv Initialization vector.
   * @param {String} algo Encryption algorithm (default: constants.cipher).
   * @return {Buffer} Encrypted data.
   */
  static encrypt(text, key, iv, algo) {
    var cipher, ciphertext;
    algo = algo || this.constants.cipher;

    if (!this.isCipherAvailable(algo)) {
      throw new Error(algo + ' is not available')
    };

    cipher = crypto.createCipheriv(algo, key, iv);
    ciphertext = cipher.update(util._strToBuffer(text));

    return Buffer.concat([ciphertext, cipher.final()]);
  }

  /**
   * Symmetric private key decryption using secret (derived) key.
   * @param {Buffer} ciphertext Data to be decrypted.
   * @param {Buffer} key Secret key.
   * @param {Buffer} iv Initialization vector.
   * @param {String} algo Encryption algorithm (default: constants.cipher).
   * @return {Buffer} Decrypted data.
   */
  static decrypt (ciphertext, key, iv, algo) {
    var decipher, plaintext;
    algo = algo || this.constants.cipher;

    if (!this.isCipherAvailable(algo)) {
      throw new Error(algo + ' is not available');
    }

    decipher = crypto.createDecipheriv(algo, key, iv);
    plaintext = decipher.update(ciphertext);

    return Buffer.concat([plaintext, decipher.final()]);
  }

  /**
   * Get the Address based on public key
   * @param {String} publicKey 32bytes of Hex String
   */
  static getAddressByPubKey(publicKey) {
    if (!util._isPublicKey(publicKey)) {
      throw new Error('Public Key is not a valid Hex String')
    }
    let ripmd160 = new RIPEMD160();
    let encodedPubKey = util._hexStringToBytes(_TYPE_ED25519 + _PUBKEY_PREFIX + publicKey);
    var buffer = new Buffer(encodedPubKey);
    return ripmd160
      .update(buffer)
      .digest('hex')
      .toUpperCase();
  }

  /**
   * Get the Address based on private key
   * @param {String} privateKey 64bytes of Hex String
   */
  static getAddressByPrivKey(privateKey) {
    if (!util._isPrivateKey(privateKey)) {
      throw new Error('Public Key is not a valid Hex String')
    }
    let publicKey = privateKey.substring(64, 128);
    return this.getAddressByPubKey(publicKey);
  }

  /**
   * Check if the selected cipher is available.
   * @param {string} algo Encryption algorithm.
   * @return {boolean} If available true, otherwise false.
   */
  static isCipherAvailable(cipher) {
    return crypto.getCiphers()
      .some(function (name) {
        return name === cipher;
      });
  }

  /**
   * Generate key pair using ed25519 curve as encryption algorithm
   * @param {Buffer} buffer [An array of bytes of seedHash hex string]
   * @returns {Object} [Contains public key and private key pair]
   */
  static makeKeyPairFromSeed(buffer) {
    return nacl.sign.keyPair.fromSeed(buffer);
  }

  /**
   * Calculate message authentication code from secret (derived) key and
   * encrypted text. The MAC is the sha256 hash of the byte array
   * formed by concatenating the second 16 bytes of the derived key with
   * the ciphertext key's contents.
   * @param {Buffer} derivedKey Secret key derived from password.
   * @param {Buffer} ciphertext Text encrypted with secret key.
   * @return {String} Hex-encoded MAC.
   */
  static createMac(derivedKey, ciphertext) {
    if (derivedKey === undefined && derivedKey === null && ciphertext === undefined && ciphertext === null) {
      throw new Error('Derived key and cipher text is required')
    }

    if (Buffer.isBuffer(derivedKey)) derivedKey = derivedKey.toString('hex');
    if (Buffer.isBuffer(ciphertext)) ciphertext = ciphertext.toString('hex');

    return crypto
      .createHash('sha256')
      .update(util._hexToUtf16le(derivedKey.slice(32, 64) + ciphertext))
      .digest()
      .toString('hex');
    // return keccak(this.hex2utf16le(derivedKey.slice(32, 64) + ciphertext));
  }

  static generateSalt(size = _SALT_SIZE) {
    return crypto.randomBytes(size)
  }

  static generateIv(size = _IV_SIZE) {
    return crypto.randomBytes(size);
  }
}

module.exports = Crypto;