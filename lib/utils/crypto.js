'use strict';

const constant = require('../constant/global'),
  util = require('./common'),
  bs58 = require('bs58'),
  crypto = require('crypto'),
  nacl = require('tweetnacl'),
  RIPEMD160 = require('ripemd160');

const _SEED_ENCODING = constant.crypto.seedHashEnco,
  _SEED_ALGORITHM = constant.crypto.seedHashAlgo,
  _SALT_SIZE = constant.crypto.saltSize,
  _IV_SIZE = constant.crypto.ivSize,
  _TYPE_ED25519 = constant.crypto.typeEd25519,
  _PUBKEY_PREFIX = constant.crypto.pubkeyPrefix,
  _AC_ADDR_ID = constant.accountAddressId,
  _VA_ADDR_ID = constant.validatorAddressId,
  _AC_ADDR_PREFIX = constant.crypto.acAddrPrefix,
  _VA_ADDR_PREFIX = constant.crypto.vaAddrPrefix,
  cxo = {};

/**
 * Generating a 32 bytes of hex string
 * @param {String} mnemonic a random string
 */
cxo.hashSeed = (seed = '', option = {}) => {
  let hash = crypto
    .createHash(option.algorithm || _SEED_ALGORITHM)
    .update(seed)
    .digest(option.encoding || _SEED_ENCODING)
    .toUpperCase();
  return hash;
}

/**
 * Generating a key pair
 * @param {String} seedHash a string which hash of seed content
 */
cxo.makeKeyPair = (seedHash) => {
  if (!util.isSeedHash(seedHash)) {
    throw new Error('String is not a valid seed hash');
  }
  let buffer = new Buffer(seedHash, 'hex');
  let keyPair = cxo.makeKeyPairFromSeed(buffer);
  return {
    publicKey: keyPair.publicKey,
    privateKey: keyPair.privateKey || keyPair.secretKey
  }
};

/**
 * Derive secret key from password with key derivation function
 * @param {String} password [User supplied password]
 * @param {String} salt [Randomly generated bytes]
 * @param {Object} option [Key derivation parameters]
 * @returns {Buffer} [Secret key derived from password]
 */
cxo.deriveKey = (password, salt, option = {}) => {
  var prf;
  option.kdfparams = option.kdfparams || {};

  if (typeof password === 'undefined' || password === null || !salt) {
    throw new Error('Must provide password and salt to derive a key');
  }

  password = util.strToBuffer(password, 'utf8');
  salt = util.strToBuffer(salt, 'utf8');

  prf = option.kdfparams.prf || constant.crypto.kdf.pbkdf2.prf;
  if (prf === 'hmac-sha256') prf = constant.crypto.kdf.pbkdf2.hash;

  if (option.kdf !== 'pbkdf2') {
    throw new Error('KDF method is not available yet. Please use pbkdf2 for now');
  }

  return crypto.pbkdf2Sync(
    password, salt,
    option.kdfparams.c || constant.crypto.kdf.pbkdf2.c,
    option.kdfparams.dklen || constant.crypto.kdf.pbkdf2.dklen,
    prf
  )
};

/**
 * Assemble key data object in secret-storage format.
 * @param {Buffer} derivedKey Password-derived secret key.
 * @param {String} privateKey Private key.
 * @param {Buffer} salt Randomly generated salt.
 * @param {Buffer} iv Initialization vector.
 * @param {Object} options Encryption parameters.
 * @param {String} options.kdf Key derivation function (default: pbkdf2).
 * @param {String} options.cipher Symmetric cipher (default: constants.cipher).
 * @param {Object} options.kdfparams KDF parameters (default: constants.<kdf>).
 * @return {Object}
 */
cxo.marshal = (derivedKey, privateKey, salt, iv, type, option = {}) => {
  var ciphertext, keyObject, algo;
  option.kdfparams = option.kdfparams || {};
  algo = option.cipher || constant.crypto.kdf.pbkdf2.cipher;

  // encrypt using first 16 bytes of derived key
  ciphertext = cxo.encrypt(privateKey, derivedKey.slice(0, 16), iv, algo).toString('hex');

  keyObject = {
    address: cxo.getAddressByPrivKey(privateKey),
    crypto: {
      cipher: option.cipher || constant.crypto.kdf.pbkdf2.cipher,
      ciphertext: ciphertext,
      cipherparams: { iv: iv.toString('hex') },
      mac: cxo.createMac(derivedKey, ciphertext)
    }
  };

  // encode address by given option
  keyObject.address = cxo.encodeAddress(keyObject.address, type);

  if (option.kdf === 'pbkdf2') {
    keyObject.crypto.kdf = 'pbkdf2';
    keyObject.crypto.kdfparams = {
      c: option.kdfparams.c || constant.crypto.kdf.pbkdf2.c,
      dklen: option.kdfparams.dklen || constant.crypto.kdf.pbkdf2.dklen,
      prf: option.kdfparams.prf || constant.crypto.kdf.pbkdf2.prf,
      salt: salt.toString('hex')
    };
  }

  return keyObject;
};

/**
 * Symmetric private key encryption using secret (derived) key.
 * @param {String} text Data to be encrypted.
 * @param {Buffer} key Secret key.
 * @param {Buffer} iv Initialization vector.
 * @param {String} algo Encryption algorithm (default: constants.cipher).
 * @return {Buffer} Encrypted data.
 */
cxo.encrypt = (text, key, iv, algo) => {
  var cipher, ciphertext;
  algo = algo || constant.crypto.encryption.cipher;

  if (!cxo.isCipherAvailable(algo)) {
    throw new Error(algo + ' is not available')
  };

  cipher = crypto.createCipheriv(algo, key, iv);
  ciphertext = cipher.update(util.strToBuffer(text));

  return Buffer.concat([ciphertext, cipher.final()]);
};

/**
 * Symmetric private key decryption using secret (derived) key.
 * @param {Buffer} ciphertext Data to be decrypted.
 * @param {Buffer} key Secret key.
 * @param {Buffer} iv Initialization vector.
 * @param {String} algo Encryption algorithm (default: constants.cipher).
 * @return {Buffer} Decrypted data.
 */
cxo.decrypt = (ciphertext, key, iv, algo) => {
  var decipher, plaintext;
  algo = algo || constant.crypto.encryption.cipher;

  if (!cxo.isCipherAvailable(algo)) {
    throw new Error(algo + ' is not available');
  }

  decipher = crypto.createDecipheriv(algo, key, iv);
  plaintext = decipher.update(ciphertext);

  return Buffer.concat([plaintext, decipher.final()]);
};

/**
 * Get the Address based on public key
 * @param {String} publicKey 32bytes of Hex String
 */
cxo.getAddressByPubKey = (publicKey) => {
  if (!util.isPublicKey(publicKey)) {
    throw new Error('Public Key is not a valid Public Key String');
  }
  let ripmd160 = new RIPEMD160();
  let encodedPubKey = util.hexStringToBytes(_TYPE_ED25519 + _PUBKEY_PREFIX + publicKey);
  var buffer = new Buffer(encodedPubKey);
  return ripmd160
    .update(buffer)
    .digest('hex')
    .toUpperCase();
};

/**
 * Get the Address based on private key
 * @param {String} privateKey 64bytes of Hex String
 */
cxo.getAddressByPrivKey = (privateKey) => {
  if (!util.isPrivateKey(privateKey)) {
    throw new Error('Private Key is not a valid Private Key string');
  }
  let publicKey = privateKey.substring(64, 128);
  return cxo.getAddressByPubKey(publicKey);
};

cxo.encodeAddress = (address, type) => {
  let newAddr, suffix, hash, checksum;
  if (!util.isAddress(address)) {
    throw new Error('Address is not a valid Address string');
  }

  if (type === _AC_ADDR_ID) suffix = _AC_ADDR_PREFIX;
  else if (type === _VA_ADDR_ID) suffix = _VA_ADDR_PREFIX;
  else throw new Error('This type is currently not supported yet!');

  newAddr = Buffer.from(address, 'hex');
  suffix = Buffer.from(suffix, 'hex');

  newAddr = Buffer.concat([suffix, newAddr], newAddr.length + suffix.length);

  // hash method
  hash = (addr) => crypto.createHash('sha256').update(addr).digest();
  // get 4 bytes of hex sum
  checksum = hash(hash(newAddr)).slice(0, 4);

  // concat new address with the checksum
  newAddr = Buffer.concat([newAddr, checksum], newAddr.length + checksum.length);
  newAddr = bs58.encode(newAddr);
  return newAddr;
};

/**
 * Check if the selected cipher is available.
 * @param {string} algo Encryption algorithm.
 * @return {boolean} If available true, otherwise false.
 */
cxo.isCipherAvailable = (cipher) => {
  return crypto.getCiphers()
    .some(function (name) {
      return name === cipher;
    });
};

/**
 * Generate key pair using ed25519 curve as encryption algorithm
 * @param {Buffer} buffer [An array of bytes of seedHash hex string]
 * @returns {Object} [Contains public key and private key pair]
 */
cxo.makeKeyPairFromSeed = (buffer) => {
  return nacl.sign.keyPair.fromSeed(buffer);
};

/**
 * Sign message with the given private key
 * @param {Buffer} message [A 64bytes buffer of the stringify transaction json data]
 * @param {Buffer} pk [A 64 bytes buffer of the private key]
 * @returns {Buffer} [An encrypted message in Buffer format]
 */
cxo.sign = (message, pk) => {
  return nacl.sign.detached(message, pk);
}

/**
 * Calculate message authentication code from secret (derived) key and
 * encrypted text. The MAC is the sha256 hash of the byte array
 * formed by concatenating the second 16 bytes of the derived key with
 * the ciphertext key's contents.
 * @param {Buffer} derivedKey Secret key derived from password.
 * @param {Buffer} ciphertext Text encrypted with secret key.
 * @return {String} Hex-encoded MAC.
 */
cxo.createMac = (derivedKey, ciphertext) => {
  if (!derivedKey && !ciphertext) {
    throw new Error('Derived key and cipher text is required')
  }

  if (Buffer.isBuffer(derivedKey)) derivedKey = derivedKey.toString('hex');
  if (Buffer.isBuffer(ciphertext)) ciphertext = ciphertext.toString('hex');

  return crypto
    .createHash('sha256')
    .update(util.hexToUtf16le(derivedKey.slice(32, 64) + ciphertext))
    .digest()
    .toString('hex');
};

/**
 * generate salt
 * @param {Number} size the size of the random bytes
 * @returns {Buffer}
 */
cxo.generateSalt = (size = _SALT_SIZE) => {
  return crypto.randomBytes(size)
};

/**
 * generate Initialization vector
 * @param {Number} size the size of the random bytes
 * @returns {Buffer}
 */
cxo.generateIv = (size = _IV_SIZE) => {
  return crypto.randomBytes(size);
}

module.exports = cxo;